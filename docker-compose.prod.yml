services:
  app:
    # === STANDARD PROD CONFIG ===

    # 1. Ports:
    # Often we bind to specific interfaces or keep it internal if using a Load Balancer.
    ports:
      - "80:8080"

    # 2. Environment:
    # 'prod' profile: Optimized HikariCP pools, JSON logging, etc.
    environment:
      - SPRING_PROFILES_ACTIVE=prod

    # === RELIABILITY ===

    # 1. Reliability (Aggressive):
    # "always" ensures the app comes back up even after a server reboot.
    restart: always

    # 2. Healthcheck (Strict):
    # If the app freezes, Docker will mark it unhealthy so the Load Balancer stops sending traffic.
    healthcheck:
      test: ["CMD-SHELL", "wget --spider -q http://localhost:8080/actuator/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3

    # === SECURITY HARDENING (Bank-Grade) ===

    # 1. Enforce Non-Root User
    # Even if the Dockerfile forgets to switch users, this forces it.
    user: springuser

    # 2. Immutable Filesystem (The "Gotcha" Fix)
    # read_only: true -> Prevents hackers from modifying ANY file in the container.
    # tmpfs: /tmp     -> CRITICAL! Spring Boot needs a scratchpad. This gives it
    #                    a writable folder in RAM, not on disk.
    read_only: true
    tmpfs:
      - /tmp

    # 3. Kernel Capability Dropping
    # Docker containers have "root-like" powers by default (ping, chown, etc.).
    # A web app needs NONE of these. We drop ALL powers.
    cap_drop:
      - ALL

    # 4. Privilege Escalation Prevention
    # Prevents a process from trying to 'sudo' or gain more rights than it started with.
    security_opt:
      - no-new-privileges:true

    # 5. Resource Limits (Strict):
    # Protect the host machine. If App uses >1GB, kill it before it crashes the OS.
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1024M
        reservations:
          memory: 512M # Guaranteed RAM